<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dino Evolution - Level 1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a3a1a, #2d5a2d);
            color: #e8d5c4;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 30%, #228B22 100%);
        }

        .game-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #32cd32;
            min-width: 300px;
        }

        .hud h3 {
            color: #32cd32;
            margin-bottom: 10px;
        }

        .species-status {
            margin-bottom: 8px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .species-name {
            color: #ff6b35;
            font-weight: bold;
        }

        .population-count {
            color: #32cd32;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }

        .control-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #32cd32;
            color: #e8d5c4;
            padding: 12px 20px;
            cursor: pointer;
            border-radius: 8px;
            font-family: inherit;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(50, 205, 50, 0.2);
            border-color: #228b22;
        }

        .control-btn:disabled {
            background: rgba(0, 0, 0, 0.4);
            border-color: #666;
            color: #666;
            cursor: not-allowed;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #32cd32;
            font-size: 1.5em;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #32cd32;
        }

        .loading-spinner {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(50, 205, 50, 0.3);
            border-radius: 50%;
            border-top-color: #32cd32;
            animation: spin 1s ease-in-out infinite;
            margin-right: 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff4444;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #ff4444;
            max-width: 500px;
        }

        .error-message h3 {
            color: #ff4444;
            margin-bottom: 15px;
        }

        .error-actions {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .error-btn {
            background: #ff6b35;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
        }

        .error-btn:hover {
            background: #ff8c42;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #8b4513;
            max-width: 250px;
        }

        .info-panel h4 {
            color: #ff6b35;
            margin-bottom: 8px;
        }

        .info-item {
            font-size: 12px;
            margin-bottom: 3px;
            color: #cd853f;
        }

        .session-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.8em;
            color: #888;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .hud {
                top: 10px;
                left: 10px;
                right: 10px;
                min-width: auto;
                max-width: calc(100% - 20px);
            }
            
            .info-panel {
                top: 10px;
                right: 10px;
                max-width: 200px;
            }
            
            .controls {
                bottom: 10px;
                flex-wrap: wrap;
                max-width: calc(100% - 20px);
            }
            
            .control-btn {
                padding: 8px 12px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" class="game-canvas"></canvas>
        
        <!-- LOADING SCREEN -->
        <div class="loading" id="loadingScreen">
            <div class="loading-spinner"></div>
            <span id="loadingText">Lade Level-Daten...</span>
        </div>

        <!-- ERROR SCREEN -->
        <div class="error-message" id="errorScreen" style="display: none;">
            <h3>‚ùå Fehler beim Laden</h3>
            <p id="errorText">Unbekannter Fehler aufgetreten</p>
            <div class="error-actions">
                <button class="error-btn" onclick="retryLoad()">üîÑ Erneut versuchen</button>
                <button class="error-btn" onclick="goBackToGenerator()">‚Üê Zur√ºck zum Generator</button>
            </div>
        </div>
        
        <!-- GAME HUD -->
        <div class="hud" id="gameHud" style="display: none;">
            <h3 id="levelTitle">üéÆ Level 1 - √úberleben</h3>
            <div id="speciesStatus"></div>
        </div>

        <!-- INFO PANEL -->
        <div class="info-panel" id="infoPanel" style="display: none;">
            <h4>üìã Steuerung</h4>
            <div class="info-item">üñ±Ô∏è Klicken: Dino ausw√§hlen</div>
            <div class="info-item">üéØ Ziel: √úberleben & Nahrung finden</div>
            <div class="info-item">‚öîÔ∏è Rote Dinos sind Feinde</div>
        </div>

        <!-- GAME CONTROLS -->
        <div class="controls" id="gameControls" style="display: none;">
            <button class="control-btn" id="pauseBtn" onclick="pauseGame()">‚è∏Ô∏è Pause</button>
            <button class="control-btn" id="speedBtn" onclick="speedUp()">‚è© Schneller</button>
            <button class="control-btn" id="saveBtn" onclick="saveProgress()">üíæ Speichern</button>
            <button class="control-btn" onclick="goBackToGenerator()">‚Üê Zur√ºck</button>
        </div>

        <!-- SESSION INFO -->
        <div class="session-info" id="sessionInfo" style="display: none;"></div>
    </div>

    <script src="dino-renderer.js"></script>

    <script>
        // ===================================
        // GLOBALE VARIABLEN
        // ===================================
        
        let canvas, ctx;
        let sessionId = null;
        let levelData = null;
        let gameObjects = [];
        let gameSpeed = 1;
        let isPaused = false;
        let animationTime = 0;
        let selectedDino = null;
        let isLoading = true;
        let saveInProgress = false;
        
        // API
        const API_BASE = 'http://localhost:3001/api/game';
        
        // Kachel-System Variablen
        let tileMap = [];
        let tileSize = 32;
        let baseTileSize = 32;
        let mapWidth = 60;
        let mapHeight = 40;
        
        // Kachel-Typen und Farben (unver√§ndert)
        const TILE_TYPES = {
            GRASS: 0,
            DIRT: 1,
            WATER: 2
        };

        const TILE_COLORS = {
            [TILE_TYPES.GRASS]: {
                base: '#228B22',
                highlight: '#32CD32',
                shadow: '#006400'
            },
            [TILE_TYPES.DIRT]: {
                base: '#8B7355',
                highlight: '#A0957A',
                shadow: '#5D4E37'
            },
            [TILE_TYPES.WATER]: {
                base: '#4682B4',
                highlight: '#87CEEB',
                shadow: '#2F4F4F'
            }
        };

        // ===================================
        // DATEN LADEN
        // ===================================

        async function loadLevelData() {
            try {
                setLoadingText('Verbinde mit Server...');
                
                // Session-ID aus URL-Parameter laden
                const urlParams = new URLSearchParams(window.location.search);
                sessionId = urlParams.get('session');
                
                if (!sessionId) {
                    throw new Error('Keine Session-ID gefunden. Bitte starten Sie vom Generator.');
                }
                
                updateSessionInfo();
                setLoadingText('Lade Level-Daten...');
                
                console.log(`üéÆ Lade Level f√ºr Session: ${sessionId}`);
                
                const response = await fetch(`${API_BASE}/load-level/${sessionId}`);
                const data = await response.json();
                
                if (data.success && data.levelData) {
                    levelData = data.levelData;
                    
                    console.log('‚úÖ Level-Daten geladen:', levelData);
                    console.log(`üìä ${levelData.populationData.length} eigene Arten, ${levelData.enemyData?.length || 0} Gegnerarten`);
                    
                    // Validierung
                    if (!levelData.populationData || levelData.populationData.length === 0) {
                        throw new Error('Keine Dinosaurier-Population gefunden. Bitte starten Sie erneut.');
                    }
                    
                    return true;
                } else {
                    throw new Error(data.error || 'Keine Level-Daten verf√ºgbar');
                }
                
            } catch (error) {
                console.error('‚ùå Fehler beim Laden der Level-Daten:', error);
                showError(error.message);
                return false;
            }
        }

        async function saveProgress() {
            if (saveInProgress || !sessionId || sessionId.startsWith('offline')) {
                return;
            }
            
            saveInProgress = true;
            const saveBtn = document.getElementById('saveBtn');
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'üíæ Speichere...';
            saveBtn.disabled = true;
            
            try {
                // Aktuelle Population aus gameObjects extrahieren
                const currentPopulation = levelData.populationData.map(species => {
                    const ownDinos = gameObjects.filter(obj => 
                        obj instanceof Dino && 
                        !obj.isEnemy && 
                        obj.species.name === species.name
                    );
                    
                    return {
                        ...species,
                        population: {
                            total: ownDinos.length,
                            adults: ownDinos.filter(d => d.isAdult).length,
                            juveniles: ownDinos.filter(d => !d.isAdult).length,
                            isExtinct: ownDinos.length === 0
                        }
                    };
                });
                
                const response = await fetch(`${API_BASE}/save-progress`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        sessionId: sessionId,
                        currentLevel: levelData.level || 1,
                        populationData: currentPopulation
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    saveBtn.textContent = '‚úÖ Gespeichert';
                    setTimeout(() => {
                        saveBtn.textContent = originalText;
                    }, 2000);
                    
                    console.log('üíæ Fortschritt gespeichert');
                } else {
                    throw new Error(data.error || 'Speichern fehlgeschlagen');
                }
                
            } catch (error) {
                console.error('‚ùå Fehler beim Speichern:', error);
                saveBtn.textContent = '‚ùå Fehler';
                setTimeout(() => {
                    saveBtn.textContent = originalText;
                }, 2000);
            } finally {
                saveBtn.disabled = false;
                saveInProgress = false;
            }
        }

        // ===================================
        // LEVEL GENERATION (angepasst)
        // ===================================

        function generateLevel() {
            if (!levelData) {
                console.error('‚ùå Keine Level-Daten verf√ºgbar');
                return;
            }
            
            console.log('=== LEVEL GENERATION START ===');
            console.log('Canvas Gr√∂√üe:', canvas.width, 'x', canvas.height);
            console.log('Level Data:', levelData);
            
            setLoadingText('Generiere Terrain...');
            
            // Kachel-Map generieren
            generateTileMap();
            
            gameObjects = [];
            let objectCounts = { trees: 0, rocks: 0, rodents: 0, ownDinos: 0, enemyDinos: 0 };
            
            setLoadingText('Platziere Umgebung...');
            
            // Umgebungsobjekte generieren (vereinfacht f√ºr bessere Performance)
            generateEnvironment(objectCounts);
            
            setLoadingText('Erwecke Dinosaurier...');
            
            // Eigene Dinos aus Level-Daten generieren
            generateOwnDinosFromData(objectCounts);
            
            // Gegner-Dinos aus Level-Daten generieren
            generateEnemyDinosFromData(objectCounts);
            
            console.log('=== OBJEKT COUNTS ===');
            console.log('B√§ume:', objectCounts.trees);
            console.log('Steine:', objectCounts.rocks);
            console.log('Nagetiere:', objectCounts.rodents);
            console.log('Eigene Dinos:', objectCounts.ownDinos);
            console.log('Gegner Dinos:', objectCounts.enemyDinos);
            console.log('Gesamt Objekte:', gameObjects.length);
            console.log('=== LEVEL GENERATION END ===');
            
            // Alle Objekte skalieren
            updateAllObjectScales();
            updateHUD();
            
            setLoadingText('Level wird geladen...');
        }

        function generateOwnDinosFromData(objectCounts) {
            console.log('=== EIGENE DINOS GENERATION START ===');
            
            levelData.populationData.forEach((species, speciesIndex) => {
                if (!species.population.isExtinct) {
                    console.log(`--- ${species.name} ---`);
                    console.log(`Generiere ${species.population.adults} Erwachsene, ${species.population.juveniles} Jungtiere`);
                    
                    // Zentraler Bereich f√ºr diese Art
                    const centerTileX = 5 + Math.random() * (mapWidth * 0.25);
                    const centerTileY = mapHeight * 0.4 + Math.random() * (mapHeight * 0.4);
                    
                    console.log(`${species.name} Zentrum: (${centerTileX.toFixed(1)}, ${centerTileY.toFixed(1)})`);
                    
                    // Erwachsene platzieren
                    for (let i = 0; i < species.population.adults; i++) {
                        const position = findValidLandPosition(centerTileX, centerTileY, 8);
                        
                        if (position.valid) {
                            const finalTileX = Math.max(2, Math.min(mapWidth * 0.45, position.tileX));
                            const finalTileY = Math.max(mapHeight * 0.35, Math.min(mapHeight - 2, position.tileY));
                            
                            gameObjects.push(new Dino(finalTileX, finalTileY, species, true, false));
                            objectCounts.ownDinos++;
                        }
                    }
                    
                    // Jungtiere platzieren
                    for (let i = 0; i < species.population.juveniles; i++) {
                        const position = findValidLandPosition(centerTileX, centerTileY, 6);
                        
                        if (position.valid) {
                            const finalTileX = Math.max(2, Math.min(mapWidth * 0.45, position.tileX));
                            const finalTileY = Math.max(mapHeight * 0.35, Math.min(mapHeight - 2, position.tileY));
                            
                            gameObjects.push(new Dino(finalTileX, finalTileY, species, false, false));
                            objectCounts.ownDinos++;
                        }
                    }
                }
            });
            
            console.log(`=== EIGENE DINOS GENERATION END: ${objectCounts.ownDinos} Dinos platziert ===`);
        }

        function generateEnemyDinosFromData(objectCounts) {
            console.log('=== GEGNER DINOS GENERATION START ===');
            
            if (!levelData.enemyData || levelData.enemyData.length === 0) {
                console.log('‚ö†Ô∏è Keine Gegner-Daten vorhanden');
                return;
            }
            
            levelData.enemyData.forEach((species, speciesIndex) => {
                if (!species.population.isExtinct) {
                    console.log(`--- Gegner ${species.name} ---`);
                    console.log(`Generiere ${species.population.adults} Erwachsene, ${species.population.juveniles} Jungtiere`);
                    
                    // Zentraler Bereich f√ºr diese Gegnerart (rechte H√§lfte)
                    const centerTileX = 5 + mapWidth * 0.65 + Math.random() * (mapWidth * 0.25);
                    const centerTileY = mapHeight * 0.4 + Math.random() * (mapHeight * 0.4);
                    
                    console.log(`Gegner ${species.name} Zentrum: (${centerTileX.toFixed(1)}, ${centerTileY.toFixed(1)})`);
                    
                    // Erwachsene platzieren
                    for (let i = 0; i < species.population.adults; i++) {
                        const position = findValidLandPosition(centerTileX, centerTileY, 8);
                        
                        if (position.valid) {
                            const finalTileX = Math.max(mapWidth * 0.55, Math.min(mapWidth - 2, position.tileX));
                            const finalTileY = Math.max(mapHeight * 0.35, Math.min(mapHeight - 2, position.tileY));
                            
                            gameObjects.push(new Dino(finalTileX, finalTileY, species, true, true));
                            objectCounts.enemyDinos++;
                        }
                    }
                    
                    // Jungtiere platzieren
                    for (let i = 0; i < species.population.juveniles; i++) {
                        const position = findValidLandPosition(centerTileX, centerTileY, 6);
                        
                        if (position.valid) {
                            const finalTileX = Math.max(mapWidth * 0.55, Math.min(mapWidth - 2, position.tileX));
                            const finalTileY = Math.max(mapHeight * 0.35, Math.min(mapHeight - 2, position.tileY));
                            
                            gameObjects.push(new Dino(finalTileX, finalTileY, species, false, true));
                            objectCounts.enemyDinos++;
                        }
                    }
                }
            });
            
            console.log(`=== GEGNER DINOS GENERATION END: ${objectCounts.enemyDinos} Dinos platziert ===`);
        }

        function generateEnvironment(objectCounts) {
            // Vereinfachte Umgebungsgenerierung f√ºr bessere Performance
            
            // Weniger B√§ume
            for (let i = 0; i < 8; i++) {
                const position = findValidLandPosition(
                    Math.random() * mapWidth, 
                    mapHeight * 0.3 + Math.random() * (mapHeight * 0.5), 
                    0
                );
                
                if (position.valid) {
                    gameObjects.push(new EnvironmentObject(position.tileX, position.tileY, 'tree'));
                    objectCounts.trees++;
                }
            }
            
            // Weniger Steingruppen
            for (let i = 0; i < 6; i++) {
                const groupCenterTileX = 5 + Math.random() * (mapWidth - 10);
                const groupCenterTileY = mapHeight * 0.5 + Math.random() * (mapHeight * 0.4);
                
                for (let j = 0; j < 3; j++) {
                    const position = findValidLandPosition(groupCenterTileX, groupCenterTileY, 2);
                    
                    if (position.valid) {
                        const rockType = j === 0 ? 'large' : (Math.random() < 0.5 ? 'medium' : 'small');
                        gameObjects.push(new EnvironmentObject(position.tileX, position.tileY, 'rock', {
                            rockType: rockType
                        }));
                        objectCounts.rocks++;
                    }
                }
            }
            
            // Weniger Nagetiere
            for (let i = 0; i < 5; i++) {
                const position = findValidLandPosition(
                    5 + Math.random() * (mapWidth - 10),
                    mapHeight * 0.6 + Math.random() * (mapHeight * 0.3),
                    0
                );
                
                if (position.valid) {
                    gameObjects.push(new EnvironmentObject(position.tileX, position.tileY, 'rodent'));
                    objectCounts.rodents++;
                }
            }
        }

        // ===================================
        // UI FUNKTIONEN
        // ===================================

        function setLoadingText(text) {
            const loadingText = document.getElementById('loadingText');
            if (loadingText) {
                loadingText.textContent = text;
            }
        }

        function showError(message) {
            const loadingScreen = document.getElementById('loadingScreen');
            const errorScreen = document.getElementById('errorScreen');
            const errorText = document.getElementById('errorText');
            
            loadingScreen.style.display = 'none';
            errorText.textContent = message;
            errorScreen.style.display = 'block';
            
            isLoading = false;
        }

        function hideLoadingShowGame() {
            const loadingScreen = document.getElementById('loadingScreen');
            const errorScreen = document.getElementById('errorScreen');
            const gameHud = document.getElementById('gameHud');
            const infoPanel = document.getElementById('infoPanel');
            const gameControls = document.getElementById('gameControls');
            const sessionInfo = document.getElementById('sessionInfo');
            
            loadingScreen.style.display = 'none';
            errorScreen.style.display = 'none';
            gameHud.style.display = 'block';
            infoPanel.style.display = 'block';
            gameControls.style.display = 'flex';
            sessionInfo.style.display = 'block';
            
            // Level-Title aktualisieren
            const levelTitle = document.getElementById('levelTitle');
            levelTitle.textContent = `üéÆ Level ${levelData.level || 1} - √úberleben`;
            
            isLoading = false;
        }

        function updateSessionInfo() {
            const sessionInfo = document.getElementById('sessionInfo');
            if (sessionId && sessionInfo) {
                if (sessionId.startsWith('offline')) {
                    sessionInfo.textContent = 'üîí Offline-Modus';
                } else {
                    sessionInfo.textContent = `üîó Session: ${sessionId.substring(0, 8)}...`;
                }
            }
        }

        function retryLoad() {
            window.location.reload();
        }

        function goBackToGenerator() {
            if (sessionId) {
                window.location.href = `index.html?session=${sessionId}`;
            } else {
                window.location.href = 'index.html';
            }
        }

        // ===================================
        // SPIEL MECHANIKEN (unver√§ndert aber angepasst)
        // ===================================

        // [Hier kommen alle bestehenden Klassen und Funktionen aus level.html]
        // Ich k√ºrze das hier f√ºr die √úbersichtlichkeit, aber es sollten alle
        // bestehenden Funktionen √ºbernommen werden:

        // - Terrain-Generation (generateTileMap, renderTile, etc.)
        // - Dino-Klasse (mit allen Bewegungen und Animationen)
        // - EnvironmentObject-Klasse  
        // - Game Loop (update, render)
        // - Input Handling (handleClick)
        // - Steuerung (pauseGame, speedUp)

        // Hier ist eine verk√ºrzte Version der wichtigsten Funktionen:

        // Resize-Funktion
        function resizeCanvas() {
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            if (levelData) {
                const oldTileSize = tileSize;
                tileSize = Math.min(canvas.width / mapWidth, canvas.height / mapHeight);
                
                if (gameObjects && gameObjects.length > 0) {
                    updateAllObjectScales();
                }
            }
        }

        // Terrain-Funktionen (vereinfacht)
        function generateTileMap() {
            if (!baseTileSize) {
                baseTileSize = Math.min(canvas.width / mapWidth, canvas.height / mapHeight);
            }
            
            tileSize = Math.min(canvas.width / mapWidth, canvas.height / mapHeight);
            
            tileMap = [];
            for (let y = 0; y < mapHeight; y++) {
                tileMap[y] = [];
                for (let x = 0; x < mapWidth; x++) {
                    // Einfache Terrain-Generation
                    if (Math.random() < 0.1) {
                        tileMap[y][x] = TILE_TYPES.WATER;
                    } else if (Math.random() < 0.6) {
                        tileMap[y][x] = TILE_TYPES.GRASS;
                    } else {
                        tileMap[y][x] = TILE_TYPES.DIRT;
                    }
                }
            }
        }

        function findValidLandPosition(centerTileX, centerTileY, maxDistanceInTiles, attempts = 20) {
            for (let attempt = 0; attempt < attempts; attempt++) {
                let testTileX, testTileY;
                
                if (maxDistanceInTiles === 0) {
                    testTileX = centerTileX;
                    testTileY = centerTileY;
                } else {
                    const angle = Math.random() * 2 * Math.PI;
                    const distance = Math.random() * maxDistanceInTiles;
                    testTileX = centerTileX + Math.cos(angle) * distance;
                    testTileY = centerTileY + Math.sin(angle) * distance;
                }
                
                const boundedTileX = Math.max(1, Math.min(mapWidth - 2, testTileX));
                const boundedTileY = Math.max(mapHeight * 0.3, Math.min(mapHeight - 2, testTileY));
                
                const tileType = getTileTypeAtPosition(Math.floor(boundedTileX), Math.floor(boundedTileY));
                
                if (tileType !== TILE_TYPES.WATER) {
                    return { tileX: boundedTileX, tileY: boundedTileY, valid: true };
                }
            }
            
            return { tileX: centerTileX, tileY: centerTileY, valid: false };
        }

        function getTileTypeAtPosition(tileX, tileY) {
            if (tileY < 0 || tileY >= mapHeight || tileX < 0 || tileX >= mapWidth) {
                return TILE_TYPES.GRASS;
            }
            
            if (tileMap[tileY] && tileMap[tileY][tileX] !== undefined) {
                return tileMap[tileY][tileX];
            }
            
            return TILE_TYPES.GRASS;
        }

        // Vereinfachte Dino-Klasse (f√ºr Demo)
        class Dino {
            constructor(tileX, tileY, species, isAdult, isEnemy = false) {
                this.tileX = tileX;
                this.tileY = tileY;
                this.species = species;
                this.isAdult = isAdult;
                this.isEnemy = isEnemy;
                this.health = isAdult ? 100 : 60;
                this.energy = 100;
                
                this.baseScale = isAdult ? 0.192 : 0.1152;
                this.scale = this.baseScale;
                this.speed = (species.properties.hinterbeine_l√§nge || 50) / 2667;
                this.targetTileX = tileX;
                this.targetTileY = tileY;
                this.selected = false;
                this.dinoType = dinoRenderer.getDinoType(species.properties);
                this.color = dinoRenderer.getDinoColor(species.properties, isEnemy);
                this.facingRight = !isEnemy;
                this.lastTileX = tileX;
                
                this.animationPhase = 'idle';
                this.phaseStartTime = Date.now();
            }

            updateScale() {
                const scaleFactor = tileSize / baseTileSize;
                this.scale = this.baseScale * scaleFactor;
            }

            update() {
                if (isPaused) return;
                
                // Vereinfachte Bewegung
                if (Math.random() < 0.01) {
                    this.targetTileX = this.tileX + (Math.random() - 0.5) * 5;
                    this.targetTileY = this.tileY + (Math.random() - 0.5) * 5;
                    
                    this.targetTileX = Math.max(1, Math.min(mapWidth - 1, this.targetTileX));
                    this.targetTileY = Math.max(mapHeight * 0.35, Math.min(mapHeight - 1, this.targetTileY));
                }
                
                const dx = this.targetTileX - this.tileX;
                const dy = this.targetTileY - this.tileY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0.3) {
                    const moveTileX = (dx / distance) * this.speed * gameSpeed;
                    const moveTileY = (dy / distance) * this.speed * gameSpeed;
                    
                    this.tileX += moveTileX;
                    this.tileY += moveTileY;
                    
                    if (moveTileX > 0.001) {
                        this.facingRight = false;
                    } else if (moveTileX < -0.001) {
                        this.facingRight = true;
                    }
                }
            }

            render() {
                const pixelX = this.tileX * tileSize + tileSize / 2;
                const pixelY = this.tileY * tileSize + tileSize / 2;
                
                const animationData = {
                    bodyAnimationY: Math.sin(animationTime * 2) * 2,
                    headAnimationX: Math.sin(animationTime * 0.8) * 3,
                    headAnimationY: Math.sin(animationTime * 1.2) * 1.5,
                    tailAnimationY: Math.sin(animationTime * 1.5) * 4,
                    frontLegAnimationX: 0,
                    backLegAnimationX: 0
                };
                
                dinoRenderer.renderDino(ctx, pixelX, pixelY, this.species.properties, this.dinoType, this.scale, this.isEnemy, animationData, this.facingRight);
                
                if (this.selected) {
                    ctx.strokeStyle = '#32cd32';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pixelX, pixelY, 14.4 * this.scale, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                
                if (this.health < 100) {
                    const barWidth = 19.2 * this.scale;
                    const barHeight = 3;
                    const barX = pixelX - barWidth/2;
                    const barY = pixelY - 19.2 * this.scale;
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(barX, barY, barWidth * (this.health/100), barHeight);
                }
            }

            isClickedBy(mouseX, mouseY) {
                const pixelX = this.tileX * tileSize + tileSize / 2;
                const pixelY = this.tileY * tileSize + tileSize / 2;
                
                const distance = Math.sqrt((mouseX - pixelX)**2 + (mouseY - pixelY)**2);
                return distance < Math.max(14.4, 19.2 * this.scale);
            }
        }

        // Vereinfachte EnvironmentObject-Klasse
        class EnvironmentObject {
            constructor(tileX, tileY, type, options = {}) {
                this.tileX = tileX;
                this.tileY = tileY;
                this.type = type;
                this.options = options;
                this.baseSize = (Math.random() * 20 + 10) * 0.32;
                this.size = this.baseSize;
            }

            updateScale() {
                const scaleFactor = tileSize / baseTileSize;
                this.size = this.baseSize * scaleFactor;
            }

            render() {
                const pixelX = this.tileX * tileSize + tileSize / 2;
                const pixelY = this.tileY * tileSize + tileSize / 2;
                
                ctx.save();
                ctx.translate(pixelX, pixelY);
                
                if (this.type === 'tree') {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-this.size/4, 0, this.size/2, this.size);
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.arc(0, -this.size/2, this.size/2, 0, 2 * Math.PI);
                    ctx.fill();
                } else if (this.type === 'rock') {
                    ctx.fillStyle = '#696969';
                    ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                } else if (this.type === 'rodent') {
                    ctx.fillStyle = '#8B4513';
                    const rodentSize = this.size * 0.5;
                    ctx.fillRect(-rodentSize/2, -rodentSize/2, rodentSize, rodentSize);
                }
                
                ctx.restore();
            }
        }

        function updateAllObjectScales() {
            gameObjects.forEach(obj => {
                if (obj.updateScale) {
                    obj.updateScale();
                }
            });
        }

        function renderTerrain() {
            const skyTileRows = 12;
            const skyHeight = skyTileRows * tileSize;
            const startTileY = skyTileRows;
            
            const gradient = ctx.createLinearGradient(0, 0, 0, skyHeight);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#B0E0E6');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, skyHeight);
            
            for (let y = startTileY; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {
                    if (tileMap[y] && tileMap[y][x] !== undefined) {
                        renderTile(x, y, tileMap[y][x]);
                    }
                }
            }
        }

        function renderTile(x, y, tileType) {
            const tileX = x * tileSize;
            const tileY = y * tileSize;
            const colors = TILE_COLORS[tileType];
            
            ctx.fillStyle = colors.base;
            ctx.fillRect(tileX, tileY, tileSize, tileSize);
            
            const shadowSize = Math.max(1, Math.floor(tileSize / 32));
            
            ctx.fillStyle = colors.highlight;
            ctx.fillRect(tileX, tileY, tileSize, shadowSize);
            ctx.fillRect(tileX, tileY, shadowSize, tileSize);
            
            ctx.fillStyle = colors.shadow;
            ctx.fillRect(tileX, tileY + tileSize - shadowSize, tileSize, shadowSize);
            ctx.fillRect(tileX + tileSize - shadowSize, tileY, shadowSize, tileSize);
        }

        // Game Loop
        function startGameLoop() {
            function gameLoop() {
                update();
                render();
                requestAnimationFrame(gameLoop);
            }
            gameLoop();
        }

        function update() {
            if (!isPaused && !isLoading) {
                animationTime += 0.016 * gameSpeed;
                
                gameObjects.forEach(obj => {
                    if (obj.update) obj.update();
                });
            }
        }

        function render() {
            if (isLoading) return;
            
            renderTerrain();
            
            gameObjects.sort((a, b) => {
                const aY = a.tileY || a.y;
                const bY = b.tileY || b.y;
                return aY - bY;
            });
            
            gameObjects.forEach(obj => obj.render());
        }

        function updateHUD() {
            if (!levelData) return;
            
            const statusContainer = document.getElementById('speciesStatus');
            let html = '';
            
            const ownDinos = gameObjects.filter(obj => obj instanceof Dino && !obj.isEnemy);
            const enemyDinos = gameObjects.filter(obj => obj instanceof Dino && obj.isEnemy);
            
            levelData.populationData.forEach(species => {
                const ownCount = ownDinos.filter(d => d.species.name === species.name).length;
                const enemyCount = enemyDinos.filter(d => d.species && d.species.name === species.name).length || 0;
                
                html += `
                    <div class="species-status">
                        <span class="species-name">${species.name}:</span>
                        <span class="population-count">Eigene: ${ownCount}</span> | 
                        <span style="color: #ff6b35;">Feinde: ${enemyCount}</span>
                    </div>
                `;
            });
            
            statusContainer.innerHTML = html;
        }

        function handleClick(event) {
            if (isLoading) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            if (selectedDino) selectedDino.selected = false;
            selectedDino = null;
            
            const dinos = gameObjects.filter(obj => obj instanceof Dino && !obj.isEnemy);
            for (let dino of dinos) {
                if (dino.isClickedBy(mouseX, mouseY)) {
                    selectedDino = dino;
                    dino.selected = true;
                    break;
                }
            }
        }

        // Steuerung
        function pauseGame() {
            isPaused = !isPaused;
            const pauseBtn = document.getElementById('pauseBtn');
            pauseBtn.textContent = isPaused ? '‚ñ∂Ô∏è Weiter' : '‚è∏Ô∏è Pause';
        }

        function speedUp() {
            gameSpeed = gameSpeed === 1 ? 2 : gameSpeed === 2 ? 4 : 1;
            const speedBtn = document.getElementById('speedBtn');
            speedBtn.textContent = 
                gameSpeed === 1 ? '‚è© Schneller' : 
                gameSpeed === 2 ? '‚è©‚è© Sehr schnell' : '‚è© Normal';
        }

        // ===================================
        // INITIALISIERUNG
        // ===================================

        async function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            baseTileSize = Math.min(canvas.width / mapWidth, canvas.height / mapHeight);
            
            console.log('üéÆ Level Canvas initialisiert:', canvas.width, 'x', canvas.height);
            
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('click', handleClick);
            
            // Level-Daten laden und Spiel starten
            const loadSuccess = await loadLevelData();
            
            if (loadSuccess) {
                setLoadingText('Generiere Level...');
                
                setTimeout(() => {
                    generateLevel();
                    hideLoadingShowGame();
                    startGameLoop();
                }, 1000);
            }
        }

        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>